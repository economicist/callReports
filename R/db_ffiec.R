#' Write extracted FFIEC schedule data to a database
#'
#' `write_ffiec_schedule()` writes the observation, codebook, and summary data
#' generated by `extract_ffiec_tsv()` to the database whose connector is
#' given by `db_connector`.
#'
#' Uses a database "transaction" to write all three tables worth of data in one
#' go and only save the data if all of it succeeds. Either everything is written
#' to the database successfully, or nothing is. This prevents duplicate data
#' being entered into the database in case one reattempts to enter a schedule
#' after a hypothetical failed attempt that gets interrupted mid-write. Using a
#' transaction allows us to respond to any failure with an error by "rolling
#' back" (undoing) any new writes to the database and returning. If successful,
#' however, we "commit" (finalize) the changes to the database so that they'll
#' be visible in future queries.
#'
#' @param db_connector A `function` created by one of the `db_connector_*()`
#' functions found in this package. It should be passed without the `()`
#' @param tbl_name The name of the table you're writing, which should be a
#' valid schedule code.
#' @param df_obs A `tibble` containing the observations found in the extracted
#' schedule file, pivoted to long form.
#' `VALUE`)
#' @param df_codes A `tibble` containing the codebook information associated
#' with the extracted schedule file.
#' @param df_summ A `tibble` containing information about how many `IDRSSD` 
#' values are associated with each `VAR_CODE` pair in the schedule
#' @export
write_ffiec_schedule <- 
  function(db_connector, sch_code, df_obs, df_codes, df_summ) {
    tbl_name <- glue::glue('FFIEC.OBS_{sch_code}')
    db_conn <- db_connector()
    DBI::dbBegin(db_conn)
    tryCatch({
      DBI::dbWriteTable(db_conn, 'FFIEC.CODEBOOK', df_codes, append = TRUE)
      rlog::log_info(glue::glue(
        'Writing {nrow(df_obs)} observations to the database...'))
      if (!DBI::dbExistsTable(db_conn, tbl_name)) {
        DBI::dbCreateTable(db_conn, tbl_name,
                           fields = c(IDRSSD      = 'INTEGER',
                                      QUARTER_ID  = 'INTEGER',
                                      VAR_CODE_ID = 'INTEGER',
                                      VALUE       = 'TEXT'))
      }
      DBI::dbWriteTable(db_conn, tbl_name, df_obs, append = TRUE)
      DBI::dbWriteTable(db_conn, 'FFIEC.SUMMARY', df_summ, append = TRUE)
      DBI::dbCommit(db_conn)
    },
    warning = function(w) {
      rlog::log_info('Warning issued while writing to database.')
      rlog::log_info('Will attempt to commit changes, but you should check the')
      rlog::log_info('contents of the database for this period.')
      warning(w)
    },
    error = function(e) {
      DBI::dbRollback(db_conn)
      rlog::log_info('Error writing to database. No observations added:')
      stop(e)
    },
    finally = {
      DBI::dbDisconnect(db_conn)
      cat('\n')
    })
  }
#' Query the FFIEC database for variables in a given database table
#' 
#' `query_ffiec_db()` connects to a given database and searches the given
#' schedule table for the requested variables.
#'
#' @param db_connector A `function` created by one of the `db_connector_*()` 
#' functions found in this package. It should be passed without the `()`
#' @param sch_code A valid alphabetical schedule code
#' @param ... Quoted variable names, separated by commas
#' @return A `tibble` containing bank ID, report date, and the values of the
#' requested variables.
#' @export
#' @examples
#' # The database connector only needs to be created once in any given script.
#' ffiec_db <- sqlite_connector('./db/ffiec.sqlite')
#' query_ffiec_db(ffiec_db, 'RCON2170', 'RCON2948', 'RCON3210')
fetch_ffiec_observations <- function(db_connector, tbl_name, ...) {
  db_conn <- db_connector()
  df_varcodes <-
    DBI::dbReadTable(db_conn, 'VAR_CODES') %>%
    dplyr::filter(VAR_CODE %in% c(...)) %>%
    dplyr::collect() %>%
    tibble::as_tibble()
  varcode_ids_csv <- paste(df_varcodes$ID, collapse = ', ')
  where_clause <- glue::glue('WHERE "VAR_CODE_ID" IN ({varcode_ids_csv})')
  db_query <- glue::glue('SELECT * FROM "{tbl_name}" {where_clause}')
  
  rlog::log_info('Requesting variables from database...')
  db_res <- DBI::dbSendQuery(db_conn, db_query)
  df_out <- 
    DBI::dbFetch(db_res) %>% tibble::as_tibble() %>%
    dplyr::mutate(REPORT_DATE = qtr_id_to_date_str(QUARTER_ID)) %>%
    dplyr::inner_join(df_varcodes, by = c('VAR_CODE_ID' = 'ID')) %>%
    dplyr::select(IDRSSD, REPORT_DATE, VAR_CODE, VALUE)
  DBI::dbClearResult(db_res)
  DBI::dbDisconnect(db_conn)
  
  rlog::log_info(glue::glue('Collected {nrow(df_out)} observations from the database.'))
  rlog::log_info('Pivoting to wide format...')
  df_out %<>%
    tidyr::pivot_wider(id_cols     = c(IDRSSD, REPORT_DATE),
                       names_from  = VAR_CODE,
                       values_from = VALUE)
  
  rlog::log_info('Query completed!')
  return(df_out)
}

#' Detect variables in the FFIEC database that exist in multiple tables
#'
#' @param db_connector A `function` created by one of the `db_connector_*()` 
#' functions found in this package. It should be passed without the `()`
#' @return A `tibble` telling you which tables a variable appearing in multiple
#' parts of the FFIEC reporting form can be found
#' @export
#' @examples
#' The database connector only needs to be created once in any given script.
#' ffiec_db <- sqlite_connector('./db/ffiec.sqlite')
#' detect_ffiec_cross_references(ffiec_db)
detect_ffiec_cross_references <- function(db_connector) {
  db_conn <- db_connector()
  df_out <-
    DBI::dbReadTable(db_conn, 'CODEBOOK') %>%
    dplyr::group_by(VAR_CODE) %>%
    dplyr::summarize(NUM_SCHEDULES = dplyr::n_distinct(SCHEDULE_CODE),
                     SCHEDULE_CODE = sort(unique(SCHEDULE_CODE)),
                     .groups = 'drop') %>%
    dplyr::filter(NUM_SCHEDULES > 1) %>%
    dplyr::arrange(VAR_CODE, SCHEDULE_CODE) %>%
    dplyr::group_by(VAR_CODE) %>%
    dplyr::mutate(INSTANCE = row_number()) %>%
    tidyr::pivot_wider(id_cols = VAR_CODE,
                       names_from = INSTANCE,
                       names_glue = 'SCHEDULE_{INSTANCE}',
                       values_from = SCHEDULE_CODE) %>%
    dplyr::arrange(SCHEDULE_1, SCHEDULE_2) %>%
    dplyr::ungroup() %>%
    dplyr::collect() %>%
    readr::type_convert()
  DBI::dbDisconnect(db_conn)
  return(df_out)
}

#' Quickly determine which periods are already in the FFIEC database
#'
#' @param db_connector A `function` created by one of the `db_connector_*()`
#' functions found in this package. It should be passed without the `()`
#' @return A character vector of dates in ISO YYYY-MM-DD format
#' @export
ffiec_schedules_in_db <- function(db_connector) {
  db_conn <- db_connector()
  if (!DBI::dbExistsTable(db_conn, 'SUMMARY')) {
    DBI::dbDisconnect(db_conn)
    return(tibble::tibble())
  }
  df_out <- DBI::dbReadTable(db_conn, 'SUMMARY') %>% dplyr::collect()
  DBI::dbDisconnect(db_conn)
  return(df_out)
}

#' Search the FFIEC data codebook in the database, by varible name or description
#'
#' Either a `var_name` or `var_desc` must be provided.
#'
#' @param db_connector A `function` created by one of the `db_connector_*()` 
#' functions found in this package. It should be passed without the `()`
#' @param var_name A valid full 8-character variable name
#' @param var_desc Any substring (case-insensitive) you hope to find in a
#' variable description
#' @return A `tibble` containing matching results in the codebook
#' @export
#' @examples
#' # The database connector only needs to be created once in any given script.
#' ffiec_db <- sqlite_connector('./db/ffiec.sqlite')
#' search_ffiec_codebook(ffiec_db, var_name = 'RCON2950')
#' search_ffiec_codebook(ffiec_db, var_desc = 'TOTAL LIABILITIES')
search_ffiec_codebook <- function(db_connector, var_name = NULL, var_desc = NULL) {
  db_conn <- db_connector()
  df_out <- DBI::dbReadTable(db_conn, 'CODEBOOK')
  if (!is.null(var_name)) {
    df_out %<>% dplyr::filter(VAR_CODE == toupper(var_name))
  }
  if (!is.null(var_desc)) {
    df_out %<>% 
      dplyr::filter(stringr::str_detect(toupper(VAR_DESC), toupper(var_desc)))
  }
  df_out %<>%
    dplyr::filter(VAR_CODE == toupper(var_name)) %>%
    dplyr::distinct(SCHEDULE_CODE, VAR_CODE, VAR_DESC) %>%
    dplyr::collect()
  DBI::dbDisconnect(db_conn)
  return(df_out)
}
